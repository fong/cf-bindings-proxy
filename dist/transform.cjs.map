{"version":3,"file":"transform.cjs","sources":["../src/transform.ts"],"sourcesContent":["import type { PropertyCall } from './proxy';\r\n\r\nexport type TransformDataType =\r\n\t| 'buffer'\r\n\t| 'blob'\r\n\t| 'stream'\r\n\t| 'base64'\r\n\t| 'text'\r\n\t| 'json'\r\n\t| 'url'\r\n\t| 'request'\r\n\t| 'response';\r\n\r\nexport type TransformRawType =\r\n\t| ArrayBuffer\r\n\t| Blob\r\n\t| string\r\n\t| NonNullable<object>\r\n\t| URL\r\n\t| Request\r\n\t| Response;\r\n\r\ntype ParseTransformFrom<T extends TransformDataType> = T extends 'buffer'\r\n\t? Extract<TransformDataType, 'base64' | 'text' | 'json'>\r\n\t: T extends 'blob' | 'stream'\r\n\t? Extract<TransformDataType, 'base64'>\r\n\t: T extends 'base64'\r\n\t? Extract<TransformDataType, 'buffer' | 'blob' | 'stream'>\r\n\t: T extends 'text'\r\n\t? Extract<TransformDataType, 'url' | 'request' | 'response'>\r\n\t: T extends 'url' | 'request' | 'response'\r\n\t? Extract<TransformDataType, 'text'>\r\n\t: never;\r\n\r\nexport type TransformRule<\r\n\tFrom extends TransformDataType = TransformDataType,\r\n\tTo extends ParseTransformFrom<From> = ParseTransformFrom<From>,\r\n> = { from: From; to: To };\r\n\r\nexport type ParseType<T extends TransformDataType> = T extends 'buffer'\r\n\t? ArrayBuffer\r\n\t: T extends 'blob'\r\n\t? Blob\r\n\t: T extends 'stream'\r\n\t? ReadableStream\r\n\t: T extends 'base64' | 'text'\r\n\t? string\r\n\t: T extends 'json'\r\n\t? NonNullable<object>\r\n\t: T extends 'url'\r\n\t? URL\r\n\t: T extends 'request'\r\n\t? Request\r\n\t: T extends 'response'\r\n\t? Response\r\n\t: never;\r\n\r\nexport type Functions = 'arrayBuffer' | 'blob' | 'json' | 'text' | 'body';\r\nexport type FunctionInfo<\r\n\tDataTransformRule extends TransformRule | undefined = TransformRule | undefined,\r\n\tData = DataTransformRule extends TransformRule ? ParseType<DataTransformRule['to']> : undefined,\r\n> = ({ data: Data; takeDataFrom?: never } | { data?: never; takeDataFrom: Functions }) & {\r\n\ttransform?: DataTransformRule;\r\n\tasAccessor?: boolean;\r\n};\r\n\r\ntype DeserializedRequest = {\r\n\turl: string;\r\n\tmethod: string;\r\n\theaders: [string, string][];\r\n\tbody: string;\r\n};\r\ntype DeserializedResponse = {\r\n\tstatus: number;\r\n\tstatusText: string;\r\n\theaders: [string, string][];\r\n\tbody: string;\r\n};\r\n\r\n/**\r\n * Transforms data from one format to another.\r\n *\r\n * @param data Data to transform.\r\n * @param transform Transform to apply.\r\n * @returns Transformed data.\r\n */\r\nexport const transformData = async <\r\n\tFrom extends TransformDataType,\r\n\tTo extends ParseTransformFrom<From>,\r\n>(\r\n\tdata: ParseType<From>,\r\n\ttransform: TransformRule<From, To>,\r\n): Promise<ParseType<To>> => {\r\n\tswitch (transform.from) {\r\n\t\tcase 'buffer': {\r\n\t\t\tif (transform.to === 'blob') {\r\n\t\t\t\treturn new Blob([data as ParseType<'buffer'>]) as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'base64') {\r\n\t\t\t\tconst bytes = new Uint8Array(data as ParseType<'buffer'>);\r\n\t\t\t\tlet binary = '';\r\n\t\t\t\tfor (let i = 0; i < bytes.byteLength; i++) {\r\n\t\t\t\t\tbinary += String.fromCharCode(bytes[i] as number);\r\n\t\t\t\t}\r\n\t\t\t\treturn btoa(binary) as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tconst asText = new TextDecoder().decode(data as ParseType<'buffer'>);\r\n\t\t\tif (transform.to === 'text') return asText as ParseType<To>;\r\n\t\t\tif (transform.to === 'json') return JSON.parse(asText) as ParseType<To>;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'blob': {\r\n\t\t\tif (transform.to === 'base64') {\r\n\t\t\t\tconst buffer = await (data as Blob).arrayBuffer();\r\n\t\t\t\treturn transformData(buffer, { from: 'buffer', to: 'base64' }) as Promise<ParseType<To>>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'stream': {\r\n\t\t\tif (transform.to === 'base64') {\r\n\t\t\t\tconst buffer = await (data as ReadableStream).getReader().read();\r\n\t\t\t\treturn transformData(buffer.value as ArrayBuffer, {\r\n\t\t\t\t\tfrom: 'buffer',\r\n\t\t\t\t\tto: 'base64',\r\n\t\t\t\t}) as Promise<ParseType<To>>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'base64': {\r\n\t\t\tif (transform.to === 'buffer') {\r\n\t\t\t\treturn Uint8Array.from(atob(data as string), (c) => c.charCodeAt(0))\r\n\t\t\t\t\t.buffer as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'blob') {\r\n\t\t\t\tconst buffer = await transformData(data as ParseType<'base64'>, {\r\n\t\t\t\t\tfrom: 'base64',\r\n\t\t\t\t\tto: 'buffer',\r\n\t\t\t\t});\r\n\t\t\t\treturn new Blob([buffer]) as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'stream') {\r\n\t\t\t\tconst buffer = await transformData(data as ParseType<'base64'>, {\r\n\t\t\t\t\tfrom: 'base64',\r\n\t\t\t\t\tto: 'buffer',\r\n\t\t\t\t});\r\n\t\t\t\tconst { readable, writable } = new FixedLengthStream(buffer.byteLength);\r\n\t\t\t\tconst writer = writable.getWriter();\r\n\t\t\t\twriter.write(buffer);\r\n\t\t\t\twriter.close();\r\n\t\t\t\treturn readable as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'url') {\r\n\t\t\t\treturn new URL(data as string) as ParseType<To>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'url': {\r\n\t\t\tif (transform.to === 'text') {\r\n\t\t\t\treturn (data as URL).toString() as ParseType<To>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'request': {\r\n\t\t\tif (transform.to === 'text') {\r\n\t\t\t\tconst asReq = data as Request;\r\n\t\t\t\treturn JSON.stringify({\r\n\t\t\t\t\turl: asReq.url,\r\n\t\t\t\t\tmethod: asReq.method,\r\n\t\t\t\t\theaders: [...asReq.headers.entries()],\r\n\t\t\t\t\tbody: await transformData(await asReq.arrayBuffer(), {\r\n\t\t\t\t\t\tfrom: 'buffer',\r\n\t\t\t\t\t\tto: 'base64',\r\n\t\t\t\t\t}),\r\n\t\t\t\t} satisfies DeserializedRequest) as ParseType<To>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'response': {\r\n\t\t\tif (transform.to === 'text') {\r\n\t\t\t\tconst asResp = data as Response;\r\n\t\t\t\treturn JSON.stringify({\r\n\t\t\t\t\tstatus: asResp.status,\r\n\t\t\t\t\tstatusText: asResp.statusText,\r\n\t\t\t\t\theaders: [...asResp.headers.entries()],\r\n\t\t\t\t\tbody: await transformData(await asResp.arrayBuffer(), { from: 'buffer', to: 'base64' }),\r\n\t\t\t\t} satisfies DeserializedResponse) as ParseType<To>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcase 'text': {\r\n\t\t\tif (transform.to === 'url') {\r\n\t\t\t\treturn new URL(data as string) as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'request') {\r\n\t\t\t\tconst deserialized = JSON.parse(data as string) as DeserializedRequest;\r\n\t\t\t\treturn new Request(deserialized.url, {\r\n\t\t\t\t\tmethod: deserialized.method,\r\n\t\t\t\t\theaders: Object.fromEntries(deserialized.headers),\r\n\t\t\t\t\tbody: deserialized.body\r\n\t\t\t\t\t\t? await transformData(deserialized.body, { from: 'base64', to: 'buffer' })\r\n\t\t\t\t\t\t: undefined,\r\n\t\t\t\t}) as ParseType<To>;\r\n\t\t\t}\r\n\r\n\t\t\tif (transform.to === 'response') {\r\n\t\t\t\tconst deserialized = JSON.parse(data as string) as DeserializedResponse;\r\n\t\t\t\treturn new Response(\r\n\t\t\t\t\tdeserialized.body\r\n\t\t\t\t\t\t? await transformData(deserialized.body, { from: 'base64', to: 'buffer' })\r\n\t\t\t\t\t\t: undefined,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstatus: deserialized.status,\r\n\t\t\t\t\t\tstatusText: deserialized.statusText,\r\n\t\t\t\t\t\theaders: Object.fromEntries(deserialized.headers),\r\n\t\t\t\t\t},\r\n\t\t\t\t) as ParseType<To>;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tdefault:\r\n\t\t// no default\r\n\t}\r\n\r\n\treturn data as unknown as ParseType<To>;\r\n};\r\n\r\n/**\r\n * Prepares the argument's data to be sent over HTTP via the binding proxy.\r\n * This will transform any `ArrayBuffer` or `Blob` to `base64` and add the `transform` property.\r\n *\r\n * @param data The data to prepare.\r\n */\r\nexport const prepareDataForProxy = async (\r\n\trawData: PropertyCallArg['data'],\r\n\tfallback: PropertyCallArg,\r\n): Promise<PropertyCallArg> => {\r\n\tif (rawData instanceof ArrayBuffer) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'base64', to: 'buffer' },\r\n\t\t\tdata: await transformData(rawData, { from: 'buffer', to: 'base64' }),\r\n\t\t};\r\n\t}\r\n\r\n\tif (rawData instanceof Blob) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'base64', to: 'blob' },\r\n\t\t\tdata: await transformData(rawData, { from: 'blob', to: 'base64' }),\r\n\t\t};\r\n\t}\r\n\r\n\tif (rawData instanceof URL) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'text', to: 'url' },\r\n\t\t\tdata: await transformData(rawData, { from: 'url', to: 'text' }),\r\n\t\t};\r\n\t}\r\n\r\n\tif (rawData instanceof Request) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'text', to: 'request' },\r\n\t\t\tdata: await transformData(rawData, { from: 'request', to: 'text' }),\r\n\t\t};\r\n\t}\r\n\r\n\tif (rawData instanceof Response) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'text', to: 'response' },\r\n\t\t\tdata: await transformData(rawData, { from: 'response', to: 'text' }),\r\n\t\t};\r\n\t}\r\n\r\n\t// NOTE: We can't use `instanceof` here as the value may not strictly be an instance of `ReadableStream`.\r\n\tif (\r\n\t\trawData !== null &&\r\n\t\ttypeof rawData === 'object' &&\r\n\t\t'getReader' in rawData &&\r\n\t\ttypeof rawData.getReader === 'function'\r\n\t) {\r\n\t\treturn {\r\n\t\t\ttransform: { from: 'base64', to: 'stream' },\r\n\t\t\tdata: await transformData(rawData as ReadableStream, { from: 'stream', to: 'base64' }),\r\n\t\t};\r\n\t}\r\n\r\n\treturn fallback;\r\n};\r\n\r\ntype PropertyCallArg = PropertyCall['args'][0];\r\n\r\nexport const transformFunctionInfo = async <Fn extends FunctionInfo>(\r\n\t{ data, takeDataFrom, transform }: Fn,\r\n\tfns: { [key in Functions]?: FunctionInfo },\r\n) => {\r\n\t// eslint-disable-next-line no-nested-ternary\r\n\tconst takenData = (\r\n\t\ttakeDataFrom ? await transformFunctionInfo(fns[takeDataFrom] as FunctionInfo, fns) : data\r\n\t) as TransformRawType | (() => TransformRawType | Promise<TransformRawType>);\r\n\r\n\tconst transformDataFn =\r\n\t\ttakenData && transform\r\n\t\t\t? async () => {\r\n\t\t\t\t\tconst derivedData =\r\n\t\t\t\t\t\ttypeof takenData === 'function' && !(takenData instanceof Blob)\r\n\t\t\t\t\t\t\t? await Promise.resolve(takenData())\r\n\t\t\t\t\t\t\t: takenData;\r\n\r\n\t\t\t\t\treturn Promise.resolve(transformData(derivedData, transform));\r\n\t\t\t  }\r\n\t\t\t: takenData ?? data;\r\n\r\n\treturn transformDataFn as TransformRawType | (() => TransformRawType | Promise<TransformRawType>);\r\n};\r\n"],"names":["transformData","data","transform","bytes","binary","i","asText","buffer","c","readable","writable","writer","asReq","asResp","deserialized","prepareDataForProxy","rawData","fallback","transformFunctionInfo","takeDataFrom","fns","takenData","derivedData"],"mappings":"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"}