{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import type { Cache, CacheStorage } from '@cloudflare/workers-types';\r\nimport { createBindingProxy } from './proxy';\r\n\r\n/**\r\n * Whether the bindings proxy is enabled and currently active.\r\n *\r\n * The proxy is enabled by default in development mode, but can be disabled by setting\r\n * `DISABLE_BINDINGS_PROXY` to `true`.\r\n *\r\n * Alternatively, it can be enabled in other environments by setting `ENABLE_BINDINGS_PROXY` to\r\n * `true`.\r\n * */\r\nexport const isProxyEnabled = () =>\r\n\ttypeof process !== 'undefined' &&\r\n\t(process?.env?.ENABLE_BINDINGS_PROXY ||\r\n\t\t(!process?.env?.DISABLE_BINDINGS_PROXY && process?.env?.NODE_ENV === 'development'));\r\n\r\n/**\r\n * Interfaces with a binding from the environment.\r\n *\r\n * @example\r\n * ```ts\r\n * const value = await binding<KVNamespace>('MY_KV').get('key');\r\n * ```\r\n *\r\n * @example\r\n * By default, `process.env` is used in production, however, a custom fallback can be provided.\r\n * ```ts\r\n * const MY_KV = binding<KVNamespace>('MY_KV', { fallback: platform.env });\r\n * ```\r\n *\r\n * @param id Binding ID.\r\n * @param opts Binding options, such as a custom fallback.\r\n * @returns Binding value.\r\n */\r\nexport const binding = <T>(id: string, opts?: BindingOpts): T => {\r\n\tif (isProxyEnabled()) {\r\n\t\treturn new Proxy(\r\n\t\t\t{},\r\n\t\t\t{\r\n\t\t\t\tget: (_, prop) => createBindingProxy<T>(id, { proxyType: 'binding' })[prop as keyof T],\r\n\t\t\t},\r\n\t\t) as T;\r\n\t}\r\n\r\n\treturn (opts?.fallback ?? process?.env)?.[id] as T;\r\n};\r\n\r\ntype DeriveCacheReturnType<T> = T extends 'default' | undefined ? Cache : Promise<Cache>;\r\n\r\n/**\r\n * Interfaces with the Cloudflare Cache API.\r\n *\r\n * By default, the `default` cache is used, however, a custom cache can be provided by passing a\r\n * cache name as the first argument.\r\n *\r\n * @example\r\n * ```ts\r\n * const value = await cacheApi().put(..., ...);\r\n * ```\r\n *\r\n * @example\r\n * ```ts\r\n * const value = await cacheApi('custom').put(..., ...);\r\n * ```\r\n *\r\n * @param cacheName Name of the cache to open, or `undefined` to open the default cache.\r\n * @returns Cache instance.\r\n */\r\nexport const cacheApi = <T extends string | undefined = undefined>(\r\n\tcacheName?: T,\r\n): DeriveCacheReturnType<T> => {\r\n\tif (isProxyEnabled()) {\r\n\t\treturn new Proxy(\r\n\t\t\t{},\r\n\t\t\t{\r\n\t\t\t\tget: (_, prop: keyof Cache) =>\r\n\t\t\t\t\tcreateBindingProxy<Cache>(cacheName ?? 'default', { proxyType: 'caches' })[prop],\r\n\t\t\t},\r\n\t\t) as DeriveCacheReturnType<T>;\r\n\t}\r\n\r\n\tconst cachesInstance = caches as unknown as CacheStorage;\r\n\r\n\treturn (\r\n\t\tcacheName === 'default' || cacheName === undefined\r\n\t\t\t? cachesInstance.default\r\n\t\t\t: cachesInstance.open(cacheName)\r\n\t) as DeriveCacheReturnType<T>;\r\n};\r\n\r\ntype BindingOpts = {\r\n\tfallback: Record<string, unknown>;\r\n};\r\n"],"names":["isProxyEnabled","_a","_b","_c","binding","id","opts","_","prop","createBindingProxy","cacheApi","cacheName","cachesInstance"],"mappings":";;AAYO,MAAMA,IAAiB,MAC7B;;AAAA,gBAAO,UAAY,UAClBC,IAAA,mCAAS,QAAT,gBAAAA,EAAc,0BACb,GAACC,IAAA,mCAAS,QAAT,QAAAA,EAAc,6BAA0BC,IAAA,mCAAS,QAAT,gBAAAA,EAAc,cAAa;AAAA,GAoB1DC,IAAU,CAAIC,GAAYC,MAA0B;;AAChE,SAAIN,MACI,IAAI;AAAA,IACV,CAAC;AAAA,IACD;AAAA,MACC,KAAK,CAACO,GAAGC,MAASC,EAAsBJ,GAAI,EAAE,WAAW,WAAW,EAAEG,CAAe;AAAA,IACtF;AAAA,EAAA,KAIMP,KAAAK,KAAA,gBAAAA,EAAM,cAAY,mCAAS,SAA3B,gBAAAL,EAAkCI;AAC3C,GAuBaK,IAAW,CACvBC,MAC8B;AAC9B,MAAIX;AACH,WAAO,IAAI;AAAA,MACV,CAAC;AAAA,MACD;AAAA,QACC,KAAK,CAACO,GAAGC,MACRC,EAA0BE,KAAa,WAAW,EAAE,WAAW,SAAU,CAAA,EAAEH,CAAI;AAAA,MACjF;AAAA,IAAA;AAIF,QAAMI,IAAiB;AAGtB,SAAAD,MAAc,aAAaA,MAAc,SACtCC,EAAe,UACfA,EAAe,KAAKD,CAAS;AAElC;"}