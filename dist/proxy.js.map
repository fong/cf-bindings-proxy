{"version":3,"file":"proxy.js","sources":["../src/proxy.ts"],"sourcesContent":["import type { FunctionInfo, Functions, ParseType, TransformRule } from './transform';\r\nimport { prepareDataForProxy, transformData, transformFunctionInfo } from './transform';\r\n\r\nexport type BindingResponse =\r\n\t| { success: false; data: string; transform?: never; functions?: never }\r\n\t| {\r\n\t\t\tsuccess: true;\r\n\t\t\tdata: unknown;\r\n\t\t\ttransform?: TransformRule;\r\n\t\t\tfunctions: { [key in Functions]?: FunctionInfo };\r\n\t  };\r\n\r\n/**\r\n * Prepares the binding request to be sent to the proxy.\r\n *\r\n * @param bindingRequest The binding request to prepare.\r\n */\r\nconst prepareBindingRequest = async (bindingRequest: BindingRequest): Promise<BindingRequest> => {\r\n\treturn {\r\n\t\t...bindingRequest,\r\n\t\t__calls: await Promise.all(\r\n\t\t\tbindingRequest.__calls.map(async (call) => ({\r\n\t\t\t\t...call,\r\n\t\t\t\targs: await Promise.all(call.args.map((arg) => prepareDataForProxy(arg.data, arg))),\r\n\t\t\t})),\r\n\t\t),\r\n\t};\r\n};\r\n\r\n/**\r\n * Fetches data from the binding proxy.\r\n *\r\n * @param call The call to make to the proxy.\r\n * @returns The data returned from the proxy.\r\n */\r\nconst fetchData = async (call: BindingRequest): Promise<unknown> => {\r\n\tconst preparedCall = await prepareBindingRequest(call);\r\n\tconst stringifiedCall = JSON.stringify(preparedCall);\r\n\r\n\tlet resp: Response;\r\n\ttry {\r\n\t\tresp = await fetch('http://127.0.0.1:8799', {\r\n\t\t\tbody: stringifiedCall,\r\n\t\t\tmethod: 'POST',\r\n\t\t\tcache: 'no-store',\r\n\t\t\theaders: { 'Content-Type': 'application/json' },\r\n\t\t});\r\n\t} catch (e) {\r\n\t\tthrow new Error('Unable to connect to binding proxy');\r\n\t}\r\n\r\n\tconst { success, data, transform, functions } = await resp.json<BindingResponse>();\r\n\r\n\tif (!success) {\r\n\t\tthrow new Error(data || 'Bad response from binding proxy');\r\n\t}\r\n\r\n\t// @ts-expect-error - We don't know the type of the data.\r\n\tconst finalData = transform ? transformData(data, transform) : data;\r\n\r\n\tif (functions && finalData && typeof finalData === 'object' && !Array.isArray(finalData)) {\r\n\t\tfor (const [key, fnInfo] of Object.entries(functions)) {\r\n\t\t\tconst transformFn = await transformFunctionInfo(fnInfo, functions);\r\n\r\n\t\t\tif (fnInfo.asAccessor) {\r\n\t\t\t\tconst value =\r\n\t\t\t\t\ttypeof transformFn === 'function' && !(transformFn instanceof Blob)\r\n\t\t\t\t\t\t? await transformFn()\r\n\t\t\t\t\t\t: transformFn;\r\n\r\n\t\t\t\tif (key === 'body') {\r\n\t\t\t\t\tconst body = new ReadableStream({\r\n\t\t\t\t\t\tstart(controller) {\r\n\t\t\t\t\t\t\tcontroller.enqueue(value);\r\n\t\t\t\t\t\t\tcontroller.close();\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tObject.defineProperties(finalData, {\r\n\t\t\t\t\t\tbody: {\r\n\t\t\t\t\t\t\tget() {\r\n\t\t\t\t\t\t\t\treturn body;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tbodyUsed: {\r\n\t\t\t\t\t\t\tget() {\r\n\t\t\t\t\t\t\t\treturn body.locked;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(finalData, key, {\r\n\t\t\t\t\t\tget() {\r\n\t\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// @ts-expect-error - this should be fine\r\n\t\t\t\tfinalData[key] = transformFn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn finalData;\r\n};\r\n\r\nexport type PropertyCall<Transform extends TransformRule | undefined = TransformRule | undefined> =\r\n\t{\r\n\t\tprop: string;\r\n\t\targs: {\r\n\t\t\tdata:\r\n\t\t\t\t| (Transform extends TransformRule ? ParseType<Transform['from']> : unknown)\r\n\t\t\t\t| BindingRequest[];\r\n\t\t\ttransform?: Transform;\r\n\t\t}[];\r\n\t};\r\n\r\nexport type ProxyType = 'binding' | 'caches';\r\n\r\nexport type BindingRequest = {\r\n\t__original_call?: BindingRequest;\r\n\t__proxyType: ProxyType;\r\n\t__bindingId: string;\r\n\t__calls: PropertyCall[];\r\n\t__chainUntil: string[];\r\n};\r\n\r\n/**\r\n * Creates a proxy object for the response data.\r\n *\r\n * @param bindingId Binding ID.\r\n * @param originalProxy Original proxy object.\r\n * @param data Data to proxy.\r\n * @returns A proxy object.\r\n */\r\nconst createResponseProxy = <T extends object>(\r\n\tproxyType: ProxyType,\r\n\tbindingId: string,\r\n\toriginalProxy: BindingRequest,\r\n\tdata: T,\r\n): T => {\r\n\treturn new Proxy(data, {\r\n\t\tget(_, prop) {\r\n\t\t\tif (!data || ['then', Symbol.iterator, Symbol.toStringTag].includes(prop)) return undefined;\r\n\r\n\t\t\tif (prop in data || ['error', 'results'].includes(prop as string)) {\r\n\t\t\t\treturn data[prop as keyof typeof data];\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(data) && typeof prop === 'string' && !Number.isNaN(Number(prop))) {\r\n\t\t\t\treturn data[Number(prop)];\r\n\t\t\t}\r\n\r\n\t\t\tif (['toJSON'].includes(prop as string)) return data;\r\n\r\n\t\t\t// special handling for `writeHttpMetadata`\r\n\t\t\tif (prop === 'writeHttpMetadata' && data && typeof data === 'object') {\r\n\t\t\t\t// @ts-expect-error - this is fine\r\n\t\t\t\tconst metadata = (data.httpMetadata || {}) as R2HTTPMetadata;\r\n\t\t\t\treturn (headers: Headers) => {\r\n\t\t\t\t\tif (metadata.cacheControl) headers.set('cache-control', metadata.cacheControl);\r\n\t\t\t\t\tif (metadata.cacheExpiry) headers.set('expires', metadata.cacheExpiry.toUTCString());\r\n\t\t\t\t\tif (metadata.contentDisposition)\r\n\t\t\t\t\t\theaders.set('content-disposition', metadata.contentDisposition);\r\n\t\t\t\t\tif (metadata.contentEncoding) headers.set('content-encoding', metadata.contentEncoding);\r\n\t\t\t\t\tif (metadata.contentLanguage) headers.set('content-language', metadata.contentLanguage);\r\n\t\t\t\t\tif (metadata.contentType) headers.set('content-type', metadata.contentType);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n\t\t\tconst newProxy = createBindingProxy<BindingRequest>(bindingId, {\r\n\t\t\t\tnotChainable: true,\r\n\t\t\t\tproxyType,\r\n\t\t\t});\r\n\r\n\t\t\tnewProxy.__original_call = originalProxy;\r\n\r\n\t\t\treturn async (...args: unknown[]) => {\r\n\t\t\t\tnewProxy.__calls.push({ prop: prop as string, args: args.map((arg) => ({ data: arg })) });\r\n\r\n\t\t\t\treturn fetchData(newProxy);\r\n\t\t\t};\r\n\t\t},\r\n\t});\r\n};\r\n\r\n/**\r\n * Decides whether or not we should chain until a certain point for a property.\r\n *\r\n * @param prop Property to check.\r\n * @returns Whether or not we should chain until certain properties.\r\n */\r\nconst shouldChainUntil = (prop: string): string[] => {\r\n\t// d1 support for chaining the `prepare` method\r\n\tif (['prepare'].includes(prop)) {\r\n\t\treturn ['first', 'run', 'all', 'raw'];\r\n\t}\r\n\r\n\treturn [];\r\n};\r\n\r\nconst buildDefaultBindingRequest = (__proxyType: ProxyType, __bindingId: string) =>\r\n\t({ __proxyType, __bindingId, __calls: [], __chainUntil: [] } as BindingRequest);\r\n\r\ntype CreateBindingOpts = { notChainable?: boolean; proxyType?: ProxyType };\r\n\r\n/**\r\n * Creates a proxy object for the binding.\r\n *\r\n * @param bindingId Binding ID.\r\n * @param notChainable Whether or not the proxy should be chainable.\r\n * @returns A proxy object.\r\n */\r\nexport const createBindingProxy = <T>(\r\n\tbindingId: string,\r\n\t{ notChainable = false, proxyType = 'binding' }: CreateBindingOpts = {},\r\n): T => {\r\n\treturn new Proxy(buildDefaultBindingRequest(proxyType, bindingId), {\r\n\t\tget(target, prop: string) {\r\n\t\t\t// internal properties\r\n\t\t\tif (typeof prop === 'string' && prop.startsWith('__'))\r\n\t\t\t\treturn target[prop as keyof BindingRequest];\r\n\t\t\t// ignore toJSON calls\r\n\t\t\tif (prop === 'toJSON') return undefined;\r\n\t\t\t// if the current proxy is not chainable, ignore calls\r\n\t\t\tif (notChainable) return undefined;\r\n\t\t\t// ignore then calls if there are no calls yet\r\n\t\t\tif (target.__calls.length === 0 && prop === 'then') return undefined;\r\n\r\n\t\t\t// decide if we should chain until a certain point for this call\r\n\t\t\tif (!target.__chainUntil.length) {\r\n\t\t\t\t// eslint-disable-next-line no-param-reassign\r\n\t\t\t\ttarget.__chainUntil = shouldChainUntil(prop);\r\n\t\t\t}\r\n\r\n\t\t\t// if we haven't reached the point where we should stop chaining, return a new proxy\r\n\t\t\tif (target.__chainUntil.length && !target.__chainUntil.includes(prop)) {\r\n\t\t\t\tconst newProxy = createBindingProxy<BindingRequest>(bindingId, { proxyType });\r\n\r\n\t\t\t\tnewProxy.__chainUntil = target.__chainUntil;\r\n\t\t\t\tnewProxy.__calls = target.__calls;\r\n\r\n\t\t\t\treturn (...args: unknown[]) => {\r\n\t\t\t\t\ttarget.__calls.push({ prop, args: args.map((arg) => ({ data: arg })) });\r\n\t\t\t\t\treturn newProxy;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn async (...args: unknown[]) => {\r\n\t\t\t\ttarget.__calls.push({ prop, args: args.map((arg) => ({ data: arg })) });\r\n\r\n\t\t\t\tconst data = await fetchData(target);\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\ttypeof data !== 'object' ||\r\n\t\t\t\t\t!data ||\r\n\t\t\t\t\tArray.isArray(data) ||\r\n\t\t\t\t\t[URL, Request, Response].find((t) => data instanceof t)\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn data;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn createResponseProxy(proxyType, bindingId, target, data);\r\n\t\t\t};\r\n\t\t},\r\n\t}) as T;\r\n};\r\n"],"names":["prepareBindingRequest","bindingRequest","call","arg","prepareDataForProxy","fetchData","preparedCall","stringifiedCall","resp","success","data","transform","functions","finalData","transformData","key","fnInfo","transformFn","transformFunctionInfo","value","body","controller","createResponseProxy","proxyType","bindingId","originalProxy","_","prop","metadata","headers","newProxy","createBindingProxy","args","shouldChainUntil","buildDefaultBindingRequest","__proxyType","__bindingId","notChainable","target"],"mappings":"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"}